#define _GNU_SOURCE
/*
 * grubenv.c - tiny GRUB environment block editor
 *
 * This program manipulates GRUB's text based environment block and aims
 * to be compatible with the 'grub-editenv' utility.  Supported commands
 * include create, list, get, set, unset and clear.  The resulting file is
 * padded with '#', just like grub-editenv generates.
 */
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <fcntl.h>

/*
 * Internal environment representation: a dynamic array of "KEY=VAL" strings
 * without the two comment header lines.  This mirrors the layout produced by
 * grub-editenv when operating on text based blocks.
 */

#define DEFAULT_BLKSZ 1024U
static uint32_t blk_size = DEFAULT_BLKSZ;

static const char header1[] = "# GRUB Environment Block\n";
static const char header2[] = "# WARNING: Do not edit this file by tools other than grub-editenv!!!\n";

struct env {
    char **items;
    size_t count;
    size_t cap;
};

static void die(const char *msg) {
    perror(msg);
    exit(EXIT_FAILURE);
}

/* Read exactly n bytes or fill the remainder with '#' */
static void read_all(int fd, uint8_t *buf, size_t n) {
    size_t off = 0;
    ssize_t r;
    while (off < n && (r = read(fd, buf + off, n - off)) > 0) {
        off += (size_t)r;
    }
    if (r < 0)
        die("read");
    while (off < n)
        buf[off++] = '#';
}

/* Write exactly n bytes or die on error */
static void write_all(int fd, const uint8_t *buf, size_t n) {
    size_t off = 0;
    ssize_t w;
    while (off < n && (w = write(fd, buf + off, n - off)) > 0) {
        off += (size_t)w;
    }
    if (w <= 0)
        die("write");
}

/* --- in-memory environment helpers --- */
/* Allocate an empty environment */
static void env_init(struct env *e) {
    e->items = NULL;
    e->count = 0;
    e->cap = 0;
}

/* Free all resources used by the environment */
static void env_free(struct env *e) {
    for (size_t i = 0; i < e->count; ++i)
        free(e->items[i]);
    free(e->items);
}

/* Append a raw KEY=VAL line */
static void env_add(struct env *e, const char *line) {
    if (e->count == e->cap) {
        size_t new_cap = e->cap ? e->cap * 2 : 4;
        char **tmp = realloc(e->items, new_cap * sizeof(*tmp));
        if (!tmp)
            die("realloc");
        e->items = tmp;
        e->cap = new_cap;
    }
    e->items[e->count++] = strdup(line);
    if (!e->items[e->count - 1])
        die("strdup");
}

/* Return index of key or -1 if missing */
static ssize_t env_find(const struct env *e, const char *key) {
    size_t klen = strlen(key);
    for (size_t i = 0; i < e->count; ++i) {
        char *eq = strchr(e->items[i], '=');
        if (eq && (size_t)(eq - e->items[i]) == klen &&
            strncmp(e->items[i], key, klen) == 0)
            return (ssize_t)i;
    }
    return -1;
}

/* Insert or replace a KEY=VAL entry */
static void env_set(struct env *e, const char *arg) {
    char *eq = strchr(arg, '=');
    if (!eq || eq == arg) {
        fprintf(stderr, "set: VAR=value required\n");
        exit(EXIT_FAILURE);
    }
    char key[eq - arg + 1];
    memcpy(key, arg, eq - arg);
    key[eq - arg] = '\0';
    ssize_t idx = env_find(e, key);
    if (idx >= 0) {
        free(e->items[idx]);
        e->items[idx] = strdup(arg);
        if (!e->items[idx])
            die("strdup");
    } else {
        env_add(e, arg);
    }
}

/* Remove a variable from the environment */
static void env_unset(struct env *e, const char *key) {
    ssize_t idx = env_find(e, key);
    if (idx < 0)
        return;
    free(e->items[idx]);
    memmove(&e->items[idx], &e->items[idx + 1], (e->count - idx - 1) * sizeof(char*));
    e->count--;
}

/* Remove all variables */
static void env_clear(struct env *e) {
    env_free(e);
    env_init(e);
}

/* Print all KEY=VAL pairs */
static void env_list(const struct env *e) {
    for (size_t i = 0; i < e->count; ++i)
        printf("%s\n", e->items[i]);
}

/* Print value of key if present. Return 0 on success, 1 if missing. */
static int env_get(const struct env *e, const char *key) {
    ssize_t idx = env_find(e, key);
    if (idx >= 0) {
        char *val = strchr(e->items[idx], '=');
        if (val)
            printf("%s\n", val + 1);
        return 0;
    }
    return 1;
}

/* Compute size of block when saved */
static size_t env_size(const struct env *e) {
    size_t sz = sizeof(header1) - 1 + sizeof(header2) - 1;
    for (size_t i = 0; i < e->count; ++i)
        sz += strlen(e->items[i]) + 1;
    return sz;
}

/* --- load/save --- */
/* Read environment block from file or stdin */
/* Read environment block from file or stdin.  Sets *existed to false if the
 * file was missing. */
static void load_env_file(const char *path, struct env *e, bool *existed) {
    uint8_t *buf = malloc(blk_size);
    if (!buf)
        die("malloc");

    if (strcmp(path, "-") == 0) {
        *existed = true;
        read_all(STDIN_FILENO, buf, blk_size);
    } else {
        int fd = open(path, O_RDONLY);
        if (fd < 0) {
            if (errno == ENOENT) {
                *existed = false;
                memset(buf, '#', blk_size);
            } else {
                die("open");
            }
        } else {
            *existed = true;
            read_all(fd, buf, blk_size);
            close(fd);
        }
    }

    env_init(e);
    char *start = (char *)buf;
    char *end = (char *)buf + blk_size;

    /* Skip mandatory first header line */
    char *nl = memchr(start, '\n', end - start);
    if (!nl) {
        free(buf);
        return;
    }
    start = nl + 1;

    /* Skip optional warning header line */
    nl = memchr(start, '\n', end - start);
    if (!nl) {
        free(buf);
        return;
    }
    if ((size_t)(nl - start) == sizeof(header2) - 1 &&
        memcmp(start, header2, sizeof(header2) - 1) == 0) {
        start = nl + 1;
    }

    while (start < end) {
        char *nl = memchr(start, '\n', end - start);
        if (!nl)
            nl = end;
        size_t len = nl - start;
        if (len == 0)
            break;
        if (start[0] != '#') {
            char *tmp = strndup(start, len);
            if (!tmp)
                die("strndup");
            env_add(e, tmp);
            free(tmp);
        }
        if (nl == end)
            break;
        if (nl + 1 >= end || nl[1] == '#')
            break;
        start = nl + 1;
    }
    free(buf);
}

/* Write environment block to file or stdout */
static void save_env_file(const char *path, struct env *e) {
    size_t used = env_size(e);
    if (used > blk_size) {
        fprintf(stderr, "env block full\n");
        exit(EXIT_FAILURE);
    }

    uint8_t *buf = malloc(blk_size);
    if (!buf)
        die("malloc");

    size_t off = 0;
    memcpy(buf + off, header1, sizeof(header1) - 1);
    off += sizeof(header1) - 1;
    memcpy(buf + off, header2, sizeof(header2) - 1);
    off += sizeof(header2) - 1;

    for (size_t i = 0; i < e->count; ++i) {
        size_t len = strlen(e->items[i]);
        memcpy(buf + off, e->items[i], len);
        off += len;
        buf[off++] = '\n';
    }

    memset(buf + off, '#', blk_size - off);

    if (strcmp(path, "-") == 0) {
        write_all(STDOUT_FILENO, buf, blk_size);
    } else {
        int fd = open(path, O_WRONLY | O_CREAT | O_TRUNC, 0644);
        if (fd < 0)
            die("open");
        write_all(fd, buf, blk_size);
        close(fd);
    }
    free(buf);
}

/* Display short usage help */
static void usage(const char *prog) {
    fprintf(stderr,
            "Usage: %s [-s size] <envfile|-> <create|list|get|set|unset|clear> [ARGS]\n",
            prog);
    exit(EXIT_FAILURE);
}

/* Entry point. Parses arguments and dispatches commands. */
int main(int argc, char *argv[]) {
    int opt;
    while ((opt = getopt(argc, argv, "s:")) != -1) {
        switch (opt) {
        case 's':
            blk_size = (uint32_t)strtoul(optarg, NULL, 0);
            if (blk_size < 128)
                die("size");
            break;
        default:
            usage(argv[0]);
        }
    }

    if (argc - optind < 2)
        usage(argv[0]);

    const char *file = argv[optind++];
    const char *cmd  = argv[optind++];

    struct env e;
    bool need_save = false;
    bool existed = true;

    if (strcmp(cmd, "create") == 0) {
        env_init(&e);
        need_save = true;
    } else {
        load_env_file(file, &e, &existed);
        if (strcmp(cmd, "list") == 0) {
            env_list(&e);
            if (!existed)
                save_env_file(file, &e);
            env_free(&e);
            return 0;
        } else if (strcmp(cmd, "get") == 0) {
            if (argc - optind != 1)
                usage(argv[0]);
            int rc = env_get(&e, argv[optind]);
            if (!existed)
                save_env_file(file, &e);
            env_free(&e);
            return rc;
        }
    }

    if (strcmp(cmd, "set") == 0) {
        if (argc - optind < 1)
            usage(argv[0]);
        for (int i = optind; i < argc; ++i)
            env_set(&e, argv[i]);
        need_save = true;
    } else if (strcmp(cmd, "unset") == 0) {
        if (argc - optind < 1)
            usage(argv[0]);
        for (int i = optind; i < argc; ++i)
            env_unset(&e, argv[i]);
        need_save = true;
    } else if (strcmp(cmd, "clear") == 0) {
        env_clear(&e);
        need_save = true;
    } else if (strcmp(cmd, "create") != 0) {
        usage(argv[0]);
    }

    if (need_save || !existed)
        save_env_file(file, &e);

    env_free(&e);
    return 0;
}

